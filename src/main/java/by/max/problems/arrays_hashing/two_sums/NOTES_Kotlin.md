# Two Sum

## Описание задачи

Дан массив целых чисел`nums`и целевое число`target`. Необходимо найти **индексы двух чисел** в массиве, сумма которых
равна целевому значению`target`.

**Ограничения:**

- Каждый входной массив имеет ровно **одно решение**

- Нельзя использовать один и тот же элемент дважды

- Ответ можно вернуть в любом порядке

**Примеры:**

**Пример 1:**
Ввод: nums = [2, 7, 11, 15], target = 9
Вывод: [0, 1]
Объяснение: nums[0] + nums[1] = 2 + 7 = 9

**Пример 2:**
Ввод: nums = [3, 2, 4], target = 6
Вывод: [1, 2]
Объяснение: nums[1] + nums[2] = 2 + 4 = 6

## Анализ решения

### Алгоритм: Однопроходная хеш-таблица

**Основная идея:**  
Использовать хеш-таблицу для хранения уже просмотренных чисел и их индексов. Для каждого текущего элемента вычисляем
разность между целевым значением и текущим элементом, затем проверяем, встречалась ли эта разность ранее.

**Алгоритм:**

1. Инициализировать пустую хеш-таблицу`mutableMapOf<Int, Int>()`

2. Пройти по массиву от начала до конца:

    - Для каждого элемента`nums[i]`вычислить`complement = target - nums[i]`

    - Если`complement`присутствует в хеш-таблице:

        - Вернуть индексы`[map[complement]!!, i]`

    - Иначе:

        - Добавить текущий элемент и его индекс в хеш-таблицу`map[nums[i]] = i`

**Визуализация для`nums = [2, 7, 11, 15]`,`target = 9`:**

| Шаг | Текущий элемент | Комплемент | Хеш-таблица | Действие                      |
|-----|-----------------|------------|-------------|-------------------------------|
| 1   | nums[0] = 2     | 7          | {}          | 7 не найден → добавляем {2:0} |
| 2   | nums[1] = 7     | 2          | {2:0}       | 2 найден → возвращаем [0,1]   |

**Kotlin-специфичные особенности:**

- Используется`mutableMapOf()`вместо`HashMap()`для более идиоматичного кода

- Оператор индексирования`map[key]`вместо методов`put()`и`get()`

- Возможно использование`forEachIndexed`для функционального подхода

### Сложность

**Временная сложность**: O(n)

- Проходим по массиву один раз (n итераций)

- Каждая операция с хеш-таблицей (вставка, поиск) в среднем занимает O(1)

**Пространственная сложность**: O(n)

- В худшем случае храним n-1 элементов в хеш-таблице

## Альтернативные подходы

### 1. Двухпроходная хеш-таблица

```kotlin
// Первый проход: заполняем хеш-таблицу
// Второй проход: ищем пару
fun twoSum(nums: IntArray, target: Int): IntArray {
    val map = mutableMapOf<Int, Int>()

    // Первый проход
    nums.forEachIndexed { index, value ->
        map[value] = index
    }

    // Второй проход
    nums.forEachIndexed { index, value ->
        val complement = target - value
        if (map.containsKey(complement) && map[complement] != index) {
            return intArrayOf(index, map[complement]!!)
        }
    }

    return intArrayOf()
}
```

**Преимущества**: Проще для понимания  
**Недостатки**: Два прохода по массиву вместо одного

### 2. Метод двух указателей (с сортировкой)

```kotlin
// Сортируем массив и используем два указателя
// с начала и конца
fun twoSum(nums: IntArray, target: Int): IntArray {
    val indexedNums = nums.withIndex().sortedBy { it.value }
    var left = 0
    var right = indexedNums.size - 1

    while (left < right) {
        val sum = indexedNums[left].value + indexedNums[right].value
        when {
            sum == target -> return intArrayOf(indexedNums[left].index, indexedNums[right].index)
            sum < target -> left++
            else -> right--
        }
    }

    return intArrayOf()
}
```

**Преимущества**: Экономия памяти (O(1) дополнительной памяти)  
**Недостатки**: Требует сортировки O(n log n), теряются оригинальные индексы

### 3. Полный перебор (Brute Force)

```kotlin
// Проверяем все возможные пары
fun twoSum(nums: IntArray, target: Int): IntArray {
    for (i in nums.indices) {
        for (j in i + 1 until nums.size) {
            if (nums[i] + nums[j] == target) {
                return intArrayOf(i, j)
            }
        }
    }
    return intArrayOf()
}
```

**Преимущества**:Простая реализация, O(1) дополнительной памяти  
**Недостатки**: Медленная работа O(n²)

### 4. Функциональный подход (Kotlin-стиль)

```kotlin
fun twoSum(nums: IntArray, target: Int): IntArray {
    val map = mutableMapOf<Int, Int>()

    nums.forEachIndexed { index, value ->
        val complement = target - value
        map[complement]?.let {
            return intArrayOf(it, index)
        }
        map[value] = index
    }

    return intArrayOf()
}
```

**Преимущества**: Идиоматичный Kotlin код, использование безопасных вызовов  
**Недостатки**: Менее читаем для новичков

## Сравнение подходов

| Подход                        | Временная сложность | Пространственная сложность | Kotlin-идиоматичность | Применимость                  |
|-------------------------------|---------------------|----------------------------|-----------------------|-------------------------------|
| **Однопроходная хеш-таблица** | **O(n)**            | O(n)                       | ★★★★☆                 | **Рекомендуемый**             |
| Функциональный подход         | O(n)                | O(n)                       | ★★★★★                 | Хорошая альтернатива          |
| Двухпроходная хеш-таблица     | O(n)                | O(n)                       | ★★★☆☆                 | Хорошая альтернатива          |
| Метод двух указателей         | O(n log n)          | O(1) или O(n)              | ★★☆☆☆                 | Если нужна экономия памяти    |
| Полный перебор                | O(n²)               | O(1)                       | ★★☆☆☆                 | Только для маленьких массивов |

## Ключевые выводы

1. **Паттерн "Хеш-таблица для поиска комплемента"**— один из самых распространенных в задачах на массивы

2. **Компромисс время-память**: хеш-таблица предлагает лучшее время выполнения за счет использования дополнительной
   памяти

3. **Условие "ровно одно решение"** упрощает реализацию, так как не требуется обработка краевых случаев

4. **Для Kotlin важно**:

    - Использование`mutableMapOf()`и оператора индексирования для более чистого кода

    - Возможность использования функциональных подходов с`forEachIndexed`

    - Null-безопасность через безопасные вызовы (`?.let{}`)

## Рекомендации

- **Используйте однопроходную хеш-таблицу**как стандартное решение для этой задачи

- **Для идиоматичного Kotlin кода**рассмотрите функциональный подход с`forEachIndexed`

- **Помните о компромиссе время-память**при выборе алгоритма

- **Тестируйте** на краевых случаях: пустой массив, отрицательные числа, дубликаты (хотя по условию решение всегда
  существует)

- **Используйте`IntArray`** вместо`Array<Int>`для лучшей производительности с примитивными типами