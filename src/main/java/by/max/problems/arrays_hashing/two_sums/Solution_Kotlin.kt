package by.max.problems.arrays_hashing.two_sums

/**
 * LeetCode 1. Two Sum
 *
 * Задача: Дан массив целых чисел nums и целое число target.
 * Необходимо найти два числа в массиве, сумма которых равна target,
 * и вернуть их индексы. Предполагается, что существует ровно одно решение,
 * и один и тот же элемент нельзя использовать дважды.
 *
 * Примеры:
 * - nums = [2, 7, 11, 15], target = 9 → [0, 1]
 * - nums = [3, 2, 4], target = 6 → [1, 2]
 * - nums = [3, 3], target = 6 → [0, 1]
 *
 * Особенности решения:
 * - Используется однопроходный алгоритм со временем выполнения O(n)
 * - Используется HashMap для хранения чисел и их индексов
 * - В отличие от Java версии, в Kotlin используется более идиоматичный синтаксис
 */
class Solution_Kotlin {
    /**
     * Находит индексы двух чисел, сумма которых равна заданной цели.
     *
     * Алгоритм:
     * 1. Проходим по массиву чисел один раз
     * 2. Для каждого числа вычисляем комплемент (complement = target - текущее число)
     * 3. Проверяем, есть ли комплемент уже в HashMap
     * 4. Если есть - возвращаем индексы [индекс_комплемента, текущий_индекс]
     * 5. Если нет - добавляем текущее число и его индекс в HashMap
     *
     * Временная сложность: O(n), где n - количество элементов в массиве
     * Пространственная сложность: O(n) для хранения HashMap
     *
     * @param nums Массив целых чисел для поиска
     * @param target Целевая сумма двух чисел
     * @return Массив из двух индексов, соответствующих числам, сумма которых равна target
     * @throws IllegalArgumentException если решение не найдено (хотя по условию всегда есть решение)
     */
    fun twoSum(nums: IntArray, target: Int): IntArray {
        // HashMap для хранения соответствия: число → индекс в массиве
        val numToIndex: MutableMap<Int, Int> = HashMap()

        // Проходим по всем элементам массива
        for (i in nums.indices) {
            // Вычисляем комплемент - число, которое в сумме с текущим дает target
            val complement = target - nums[i]

            // Проверяем, встречали ли мы уже комплемент ранее
            if (numToIndex.containsKey(complement)) {
                // Если нашли комплемент, возвращаем индексы
                // map.getValue(complement) - индекс комплемента
                // i - текущий индекс
                return intArrayOf(numToIndex.getValue(complement), i)
            }

            // Если комплемент не найден, добавляем текущее число и его индекс в карту
            // Используем оператор индексирования map[key] = value вместо put()
            numToIndex[nums[i]] = i
        }

        // По условию задачи решение всегда существует,
        // но для безопасности возвращаем пустой массив
        return intArrayOf()
    }
}